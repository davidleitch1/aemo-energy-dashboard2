{
  "permissions": {
    "allow": [
      "Bash(cd:*)",
      "Bash(cd:*)",
      "Bash(cd:*)",
      "Bash(cd:*)",
      "Bash(cd:*)",
      "Bash(chmod:*)",
      "Bash(.venv/bin/python:*)",
      "Bash(cd:*)",
      "Bash(pkill:*)",
      "Bash(true)",
      "Bash(cd:*)",
      "Bash(cd:*)",
      "Bash(cd:*)",
      "Bash(cd:*)",
      "Bash(cd:*)",
      "Bash(cd:*)",
      "Bash(curl:*)",
      "Bash(unzip:*)",
      "Bash(rm:*)",
      "Bash(grep:*)",
      "Bash(.venv/bin/pip install:*)",
      "Bash(uv pip install:*)",
      "Bash(python:*)",
      "Bash(ls:*)",
      "Bash(/opt/homebrew/Caskroom/miniforge/base/bin/python -c \"\nimport pandas as pd\nimport numpy as np\n\n# Load the data\ndf = pd.read_parquet(''data 2/rooftop30.parquet'')\n\nprint(''=== ROOFTOP30.PARQUET VERIFICATION ==='')\nprint(f''Total records: {len(df):,}'')\nprint(f''Date range: {df[\"\"settlementdate\"\"].min()} to {df[\"\"settlementdate\"\"].max()}'')\nprint(f''Regions: {sorted(df[\"\"regionid\"\"].unique())}'')\n\n# Check 2024 coverage\ndf_2024 = df[df[''settlementdate''].dt.year == 2024]\nprint(f''\\n2024 Data: {len(df_2024):,} records'')\nprint(''2024 Monthly coverage:'')\nfor month in range(1, 13):\n    month_data = df_2024[df_2024[''settlementdate''].dt.month == month]\n    if len(month_data) > 0:\n        print(f''  Month {month}: {len(month_data):,} records, {month_data[\"\"settlementdate\"\"].min()} to {month_data[\"\"settlementdate\"\"].max()}'')\n\n# Check 2025 coverage\ndf_2025 = df[df[''settlementdate''].dt.year == 2025]\nprint(f''\\n2025 Data: {len(df_2025):,} records'')\nprint(''2025 Monthly coverage:'')\nfor month in range(1, 8):\n    month_data = df_2025[df_2025[''settlementdate''].dt.month == month]\n    if len(month_data) > 0:\n        print(f''  Month {month}: {len(month_data):,} records, {month_data[\"\"settlementdate\"\"].min()} to {month_data[\"\"settlementdate\"\"].max()}'')\n\n# Data quality\nprint(f''\\nData Quality:'')\nprint(f''  Min value: {df[\"\"rooftop_solar\"\"].min():.2f} MW'')\nprint(f''  Max value: {df[\"\"rooftop_solar\"\"].max():.2f} MW'')\nprint(f''  Mean value: {df[\"\"rooftop_solar\"\"].mean():.2f} MW'')\nprint(f''  Negative values: {(df[\"\"rooftop_solar\"\"] < 0).sum()}'')\nprint(f''  Null values: {df[\"\"rooftop_solar\"\"].isna().sum()}'')\n\")",
      "Bash(/Users/davidleitch/miniforge3/bin/python3 -m pip install pandas pyarrow)",
      "Bash(/Users/davidleitch/miniforge3/bin/python3 verify_rooftop_pandas.py)",
      "Bash(/Users/davidleitch/miniforge3/bin/python3 -c \"\nimport pandas as pd\n\n# Load the data\ndf = pd.read_parquet(''data 2/rooftop30.parquet'')\n\nprint(''Column names:'', df.columns.tolist())\nprint(''First few rows:'')\nprint(df.head())\n\")",
      "Bash(/Users/davidleitch/miniforge3/bin/python3 -c \"\nimport pandas as pd\nimport numpy as np\n\n# Load the data\ndf = pd.read_parquet(''data 2/rooftop30.parquet'')\n\nprint(''================================================================================'')\nprint(''ROOFTOP30.PARQUET VERIFICATION REPORT'')\nprint(''================================================================================'')\n\n# 1. Overall summary\nprint(''\\n1. OVERALL DATA SUMMARY'')\nprint(''-'' * 40)\nprint(f''Total records: {len(df):,}'')\nprint(f''Date range: {df[\"\"settlementdate\"\"].min()} to {df[\"\"settlementdate\"\"].max()}'')\nprint(f''Total days: {df[\"\"settlementdate\"\"].dt.date.nunique():,}'')\nprint(f''Regions: {sorted(df[\"\"regionid\"\"].unique())}'')\n\n# 2. 2024 Data Coverage\nprint(''\\n2. 2024 DATA COVERAGE'')\nprint(''-'' * 40)\ndf_2024 = df[df[''settlementdate''].dt.year == 2024]\nprint(f''Total 2024 records: {len(df_2024):,}'')\n\n# Monthly breakdown for 2024\nprint(''\\nMonthly breakdown:'')\nmonth_names = [''Jan'', ''Feb'', ''Mar'', ''Apr'', ''May'', ''Jun'', ''Jul'', ''Aug'', ''Sep'', ''Oct'', ''Nov'', ''Dec'']\nfor month in range(1, 13):\n    month_data = df_2024[df_2024[''settlementdate''].dt.month == month]\n    if len(month_data) > 0:\n        days = month_data[''settlementdate''].dt.date.nunique()\n        avg_power = month_data[''power''].mean()\n        max_power = month_data[''power''].max()\n        print(f''  {month_names[month-1]}: {len(month_data):>6,} records ({days} days), ''\n              f''Avg: {avg_power:>7.1f} MW, Max: {max_power:>7.1f} MW'')\n\n# Special focus on Aug-Dec 2024\nprint(''\\nAug-Dec 2024 by region:'')\nfor month in range(8, 13):\n    month_data = df_2024[df_2024[''settlementdate''].dt.month == month]\n    if len(month_data) > 0:\n        print(f''  {month_names[month-1]}:'')\n        for region in sorted(month_data[''regionid''].unique()):\n            region_data = month_data[month_data[''regionid''] == region]\n            print(f''    {region}: {len(region_data):>4,} records'')\n\n# 3. 2025 Data Coverage\nprint(''\\n3. 2025 DATA COVERAGE'')\nprint(''-'' * 40)\ndf_2025 = df[df[''settlementdate''].dt.year == 2025]\nprint(f''Total 2025 records: {len(df_2025):,}'')\n\n# Monthly breakdown for 2025\nprint(''\\nMonthly breakdown:'')\nfor month in range(1, 8):  # Up to July\n    month_data = df_2025[df_2025[''settlementdate''].dt.month == month]\n    if len(month_data) > 0:\n        days = month_data[''settlementdate''].dt.date.nunique()\n        avg_power = month_data[''power''].mean()\n        max_power = month_data[''power''].max()\n        print(f''  {month_names[month-1]}: {len(month_data):>6,} records ({days} days), ''\n              f''Avg: {avg_power:>7.1f} MW, Max: {max_power:>7.1f} MW'')\n\n# 4. Gap Analysis\nprint(''\\n4. GAP ANALYSIS'')\nprint(''-'' * 40)\n\n# Check for gaps in recent months\nfor year in [2024, 2025]:\n    year_data = df[df[''settlementdate''].dt.year == year]\n    if len(year_data) > 0:\n        print(f''\\n{year} Gaps:'')\n        for region in sorted([''NSW1'', ''QLD1'', ''SA1'', ''VIC1'', ''TAS1'']):  # Main regions only\n            region_data = year_data[year_data[''regionid''] == region].sort_values(''settlementdate'')\n            if len(region_data) > 0:\n                # Expected intervals (48 per day)\n                days = (region_data[''settlementdate''].max() - region_data[''settlementdate''].min()).days + 1\n                expected_records = days * 48\n                actual_records = len(region_data)\n                if actual_records < expected_records:\n                    missing = expected_records - actual_records\n                    coverage = (actual_records / expected_records) * 100\n                    print(f''  {region}: {missing:,} missing intervals ({coverage:.1f}% coverage)'')\n\n# 5. Data Quality\nprint(''\\n5. DATA QUALITY'')\nprint(''-'' * 40)\nprint(f''Power value range: {df[\"\"power\"\"].min():.2f} to {df[\"\"power\"\"].max():.2f} MW'')\nprint(f''Average power: {df[\"\"power\"\"].mean():.2f} MW'')\nprint(f''Negative values: {(df[\"\"power\"\"] < 0).sum():,}'')\nprint(f''Null values: {df[\"\"power\"\"].isna().sum():,}'')\nprint(f''Extreme values (>10,000 MW): {(df[\"\"power\"\"] > 10000).sum():,}'')\n\n# Check daily pattern\nprint(''\\nTypical daily pattern (2025 average):'')\ndf_2025[''hour''] = df_2025[''settlementdate''].dt.hour\nhourly = df_2025.groupby(''hour'')[''power''].mean()\nfor hour in [0, 6, 9, 12, 15, 18, 21]:\n    if hour in hourly.index:\n        print(f''  Hour {hour:02d}: {hourly[hour]:>7.1f} MW'')\n\n# 6. Summary by Year\nprint(''\\n6. YEARLY SUMMARY'')\nprint(''-'' * 40)\nyearly = df.groupby(df[''settlementdate''].dt.year).agg({\n    ''settlementdate'': ''count'',\n    ''power'': [''sum'', ''mean'', ''max'']\n})\nyearly.columns = [''records'', ''total_mw'', ''avg_mw'', ''max_mw'']\nyearly[''total_gwh''] = yearly[''total_mw''] * 0.5 / 1000  # Convert to GWh\n\nprint(f''Year | Records | Avg MW | Max MW | Total GWh'')\nprint(''-'' * 50)\nfor year in yearly.index:\n    row = yearly.loc[year]\n    print(f''{year} | {row[\"\"records\"\"]:>7,} | {row[\"\"avg_mw\"\"]:>6.0f} | {row[\"\"max_mw\"\"]:>6.0f} | {row[\"\"total_gwh\"\"]:>9,.0f}'')\n\")",
      "Bash(find:*)",
      "Bash(kill:*)",
      "Bash('git rm --cached --ignore-unmatch .env.all_migrated .env.backup_20250718_064025 .env.gen_trans_test .env.generation_test .env.new' )",
      "Bash('git rm --cached --ignore-unmatch .env.all_migrated .env.backup_20250718_064025 .env.gen_trans_test .env.generation_test .env.new' )",
      "Bash(./create_clean_repo.sh:*)",
      "Bash(mv:*)",
      "Bash(source:*)",
      "Bash(/Users/davidleitch/Library/Mobile Documents/com~apple~CloudDocs/snakeplay/AEMO_spot/aemo-data-updater/.venv/bin/python -c \"\nimport requests\n\nurl = ''http://nemweb.com.au/Reports/CURRENT/TradingIS_Reports/PUBLIC_TRADINGIS_202507201955_0000000472810592.zip''\nheaders = {''User-Agent'': ''AEMO Dashboard Data Collector''}\n\nprint(f''Testing: {url}'')\ntry:\n    r = requests.get(url, headers=headers, timeout=60)\n    print(f''Status code: {r.status_code}'')\n    if r.status_code == 403:\n        print(''Got 403!'')\n        print(f''Response headers: {r.headers}'')\n        print(f''Response text preview: {r.text[:200]}...'')\n    elif r.status_code == 404:\n        print(''File not found (404)'')\n    else:\n        print(f''File size: {len(r.content)} bytes'')\nexcept Exception as e:\n    print(f''Exception: {type(e).__name__}: {e}'')\n\")",
      "Bash(/Users/davidleitch/Library/Mobile Documents/com~apple~CloudDocs/snakeplay/AEMO_spot/aemo-data-updater/.venv/bin/python -c \"\nimport requests\n\nurl = ''http://nemweb.com.au/Reports/CURRENT/TradingIS_Reports/PUBLIC_TRADINGIS_202507201955_0000000472810592.zip''\nheaders = {''User-Agent'': ''AEMO Dashboard Data Collector''}\n\nr = requests.get(url, headers=headers, timeout=60)\nprint(f''Status code: {r.status_code}'')\nprint(f''Content type: {r.headers.get(\"\"Content-Type\"\")}'')\nprint(f''File size: {len(r.content)} bytes'')\n\n# Check if it''s actually a zip or HTML\nif r.content.startswith(b''PK''):\n    print(''This is a ZIP file'')\nelif b''<html'' in r.content.lower() or b''<!doctype'' in r.content.lower():\n    print(''This is HTML (not a ZIP!)'')\n    print(''Content preview:'')\n    print(r.text[:500])\nelse:\n    print(''Unknown content type'')\n    print(''First 100 bytes:'', r.content[:100])\n\")",
      "Bash(/Users/davidleitch/Library/Mobile Documents/com~apple~CloudDocs/snakeplay/AEMO_spot/aemo-data-updater/.venv/bin/python -c \"\nimport requests\nimport zipfile\nimport io\n\nurl = ''http://nemweb.com.au/Reports/CURRENT/TradingIS_Reports/PUBLIC_TRADINGIS_202507201955_0000000472810592.zip''\nheaders = {''User-Agent'': ''AEMO Dashboard Data Collector''}\n\nr = requests.get(url, headers=headers, timeout=60)\nprint(f''Downloaded {len(r.content)} bytes'')\n\ntry:\n    with zipfile.ZipFile(io.BytesIO(r.content)) as z:\n        print(f''ZIP contains: {z.namelist()}'')\n        for name in z.namelist():\n            info = z.getinfo(name)\n            print(f''  {name}: {info.file_size} bytes'')\n            if info.file_size < 1000:  # Small file, let''s see what''s in it\n                content = z.read(name).decode(''utf-8'', errors=''ignore'')\n                print(f''  Content: {content[:200]}'')\nexcept Exception as e:\n    print(f''Error reading ZIP: {e}'')\n\")",
      "WebFetch(domain:panel.holoviz.org)",
      "Bash(git remote add:*)",
      "Bash(git remote remove:*)",
      "Bash(git remote:*)",
      "Bash(cp:*)"
    ],
    "deny": []
  }
}